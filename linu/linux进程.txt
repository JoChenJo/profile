递归遍历目录：1s-R.c
	1、判断命令行参数，获取用户要查询的目录名。	argv[1]
		argc == 1   --> ./
	2、判断用户指定的是否是目录。stat    S_ISDIR();	-->封装函数   isFile
	3.读目录：
		pendir(dir)
		while( readdir() ) {
			普通文件，直接打印
			目录：
				拼接目录访问绝对路径。sorintf(path,"%s%s"，dir，d_name)
				递归调用自己。-->opendir（path）readdir   closedir
		}
		closedir（）
dup和dup2：
	int dup（int oldfd）；	int dup2（int oldfd，int  newfd）
		oldfd：已有文件描述符
		返回：新文件描述符
fcntl函数实现dup：
	int fcntl（int fd，int cmd，..）
	cmd：F_DUPFD
	参数3：被占用的，返回最小可用的。
		未被占用的，返回=该值的文件描述符。
=========================================================================================
进程：
	程序：死的。只占用磁盘空间。		--剧本。
	进程：活得。运行起来的程序。占用内存、cpu等系统资源。	--戏。
PCB进程控制块
	进程id
	文件描述符
	进程状态：初始态、就绪态、运行态、挂起态、终止态。
	进程工作目录位置
	*umask掩码
	信号相关信息资源
	用户id和组id
fork函数：
	pid_t  fork(void)
	创建子进程。父子进程各自返回。父进程返回子进程pid。子进程返回0.
	getpid();	getppid();
	循环创建N个子进程模型。每个子进程标识自己的身份。
父子进程相同：
	刚fork后。data段、text段、堆、栈、环境变量、全局变量、宿主目录位置、进程工作目录位置、进程工作目录位置、信号处理方式
父子进程不同：
	进程id、返回值、各自的父进程、进程创建时间、闹钟、未决信号集
父子进程共享：
	读时共享，写时复制。-----------全局变量。
	1、文件描述符	2、mmap映射区。

孤儿进程：
	父进程先于子进程终止，子进程沦为”孤儿进程“，会被init进程领养
僵尸进程：
	子进程终止，父进程尚未对子进程进程回收，在此期间，子进程为”僵尸进程“。
wait函数：	回收子进程退出资源，阻塞回收任意一个。
	函数作用1：	阻塞等待子进程退出
	函数作用2：	清理子进程残留在内核的pcb资源
	函数作用3：通过传出参数，得到子进程结束状态
	获取子进程正常终止值，
		WIFEXITED(status) -->为真-->调用WEXITSTATUS(status）-->得到子进程退出值
	获取导致子进程异常终止信号：
		WIFSIGNALED(status）-->为真->>调用WTERMSIG(status）-->得到导致子进程异常终止的信号编号

waitpid函数：指定某一个进程进行回收。可以设置非阻塞。		waitpid（-1，&status，0）==wait（&status）；
	pid_t   waitpid（pid_t  pid，int  *status，int  options）
	参数：
		pid：指定回收的某一个子进程pid
			>0：待回收回收的子进程pid
			-1：任意子进程
			0：同组的子进程。
		status：（传出）回收进程的状态。
		options：WNOHANG  指定回收方式为，非阻塞。
	返回值：
		>0：表成功回收的子进程pid
		0：函数调用时，参3指定了WNOHANG，并且，没有子进程结束。
		-1：失败。errno

总结：
	wait、waitpid     一次调用，回收一个子进程。
		          想回收多个。while	

守护进程：
	daemon进程。通常运行与操作系统后台，脱离控制终端。一般不与用户直接交互。周期性的等待某个事件发生或周期性执行某一动作。
	不受用户登录注销影响。通常采用以d结尾的命名方式。
守护进程创建步骤：
	1、fork子进程，让父进程终止。
	2、子进程调用setsid（）创建新会话
	3、通常根据需要，改变工作目录位置chdir（）
	4、通常根据需要，重设umask文件权限掩码
	5、通常根据需求，关闭/重定向  文件描述符
	6、守护进程  业务逻辑。while（）
================================================================================================
管道：
	实现原理：内核借助环形队列机制，使用内核缓冲区实现。
	特质：1、伪文件
	          2、管道中的数据只能一次读
	          3、数据在管道中，只能单向流动。
             局限性：1、自己写，不能自己读。
	          2、数据不可以反复读。 
	          3、半双工通信。
	          4、血缘关系进程间可用。

pipe函数：创建并打开管道
	int  pipe（int fd[2]）；
	参数：fd[0]：读端。   fd[1]：写端。
	返回值：成功：0	失败：	-1  errno
管道的读写行为：
	读管道：
		1、管道有数据，read返回实际读到的字节数。
		2、管道无数据：1）无写端，read返回0（类似读到文件尾）
	写管道：
		1、无读端，异常终止。（SIGPIPE导致的）
		2、有读端：	1）管道已满：阻塞等待
				2）管道未满：返回写出的字节个数。
pipe管道：
	父子进程间通信	兄弟间通信
fifo管道：
	无血缘关系进程间通信

void  *mmap（void *addr，size_t  length，int prot，int  flags，int fd，off_t offset）；	创建共享内存映射
	参数：
		addr：指定映射区的首地址。通常传BULL，表示让系统自动分配
		lenhth：共享内存映射区的大小。（<=文件的实际大小）
		prot：共享内存映射的读写属性。PROT_READ、PROT_WRITE、PROT_READ | PROT_WRITE
		flags：标注共享内存的共享属性。MAP_SHEARED、MAP_PRIVATE
		fd：用于创建共享内存映射区的那个文件夹的文件描述符。
		offset：偏移位置。需是4k的整数倍。
	返回值：
		成功：映射区的首地址。	失败：MAP_FAILED，errno

int  nunmap（void *addr，size_t  length）；	释放映射区
	addr：mmap的返回值
	length：大小
使用注意事项：
	1、用于创建映射区的文件大小为0，实际制定非0大小创建映射区，出”总线错误“。
	2、用于创建映射区的文件大小为0，实际制定0大小创建映射区，出”无效参数“。
	3、用于创建映射区的文件读写属性为，只读。映射区属性为读、写。出”无效参数“。
	4、创建映射区，需要read权限。当访问权限为”共享“MAP_SHARED时，mmap的读写权限，应该<=文件的open权限。只写不行。
	5、文件描述符id，在mmap创建映射区完成即可关闭。后续访问文件，用地址访问。
	6、offset必须是4096的整数倍。（MMU映射的最小单位4k)
	7、对申请的内存，不能越界访问。
	8、munmap用于释放的地址，必须是mmap申请返回的地址。
	9、映射区访问权限为”私有“MAP_PRIVATE，对内存所作的所有修改，只在内存有效，不会反应到物理磁盘上。
	10、映射区访问权限为”私有“MAP_PRIVATE，只需要open文件时，有读权限，用于创建映射区域
mmap函数的保险调用方式：
	1、fd = open（”文件名“，O_RDWR)
	2、mmap（NULL，有效文件大小，PROT_READ | PROT_WRITE,MAP_SHARED，fd，0）；
父进程使用mmap进程间通信：
	父进程先创建 映射区。open（O_RDWR)   map（MAP_SHARED）；
	指定MAP_SHARED 权限
	fork（）创建子进程。
	一个进程读，另一个进程写。
无血缘关系进程间mmap通信
	两个进程打开同一个文件，创建映射区。
	指定flags为MAP_SHARED。
	一个进程写入，另一个进程读出。
	【注意】：无血缘关系进程间通信。mmap：数据可以重复读取。fufo：数据只能一次读取。
匿名映射：只能用于血缘关系进程间通信
	p = （int *）mmap（NULL，40，PROT_READ | PROT_WRITE，MAP_SHARED | MAP_ANONYMOUS，-1，0）；






